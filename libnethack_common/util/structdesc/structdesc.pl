#!/usr/bin/perl
use utf8;     # this source file is UTF-8
use warnings;
use strict;
use 5.8.3;

# structdesc: structure description language compiler
# Copyright Â© 2014, 2015 Alex Smith.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of version 3 of the GNU General Public License can be viewed
# online at <http://www.gnu.org/licenses/>. If you obtained
# structdesc as part of NetHack 4, you can also view this license
# as the file libnethack/dat/gpl3.
#
# Alternatively, at your option, you can redistribute and/or modify this
# program under the terms of the NetHack General Public License; see
# libnethack/dat/license for the details. Regardless of which license you
# choose, this program is distributed WITHOUT ANY WARRANTY.

=encoding utf8

=head1 NAME

structdesc - structure description language compiler

=head1 SYNOPSIS

B<perl> F<structdesc.pl> I<options> F<file.sd>

At least one output-producing option must be given; more than one
output-producing option can be given to produce multiple sorts of output in
one run of the program.

=head1 DESCRIPTION

Projects in statically-typed languages can have a lot of boilerplate code when
handling structures; the type of the structure itself needs to be defined in a
header file (perhaps including comments documenting the invariants), code may
be needed to serialize and deserialize it (perhaps in a range of formats!),
code might be needed to check the invariants (or accessors/mutators
implemented that enforce them), code might be needed to clone the structure.
This is a particular problem in C, which also has to contend with a range of
memory allocation schemes, and thus may also need code to deallocate a
structure, and multiple different ways to clone it; and unlike some languages,
there is no support in the language itself for autogenerating some of the
boilerplate.

F<structdesc> attempts to solve this problem via allowing structures to be
described in a relatively low-level way (although slightly higher than C), but
in enough detail to allow all this code to be autogenerated.  In general, if
there are two (or more) different ways to represent a data type in C, there
are as many ways to represent it in an F<.sd> file; thus (for instance) if you
want your strings in fixed-size buffers, it'll look different from if you want
them in heap memory.  This means that you can convert an existing header to
F<structdesc> format, and the code that uses it should need few or no changes.

The F<.sd> format also allows specifying some simple invariants.  These will
be taken into account when generating code (for instance, if a struct field is
marked as C<defined_when> relative to a field that has a null value, it will
not be included in serialized output, and cause an error if included in
deserialized output).  Invariants thus have an effect on the generated code.

=head1 OPTIONS

Options that control output:

=over 4

=item B<--c-header=>F<file.h>

Generate a C header file from the given structure description file, containing
the types it specifies.

=item B<--c=>F<file.c>

Generate a C source file from the given structure description file, containing
subroutines that perform tasks specified via other output control options.

=item B<--c-externs=>F<file.h>

Generate a C header file that contains appropriate declarations for the
functions in any C source files that are output.

=item B<--deallocate=>I<types>

Generate routines to deallocate memory used by the given types.  The list of
I<types> can be specified as an explicit, comma-separated list, C<_all> for
all types present in the file, or C<_dynamic> for all types that actually have
dynamic data to deallocate.  These routines will be placed in each source file
you requested F<structdesc> to generate (currently, only C is supported,
but if multiple languages were supported, you could give two "output a source
file" options and get your deallocation routines in two different languages.)

The routines will be named C<deallocate_>I<type>.  In C, they look like this:

    void deallocate_type(type *data, void *deallocatorarg,
                         void *(*deallocator)(void *deallocatorarg));

The deallocator can be specified as NULL to use C<free()>.

=item B<--deinitialize=>I<types>

Identical to B<--deallocate>, except that the generated routines only free
dynamic memory owned by the structure they are freeing; they don't free the
structure itself.  (Thus, C<deallocate_type> starts with a pointer to a
structure and causes the memory it points to to become deallocated;
C<deinitialize_type> starts with a pointer to a structure and causes all the
pointers inside that structure to become invalid, meaning that the structure
may not respect its invariants and is thus effectively composed of
uninitialized memory.)

=item B<--clone=>I<types>

Generate routines to clone the given types.  (These take an allocator as a
parameter, allowing you to use a variety of memory schemes within your
program.)  I<types> works the same way as for B<--deallocate> (as it does in
all these options).  Whether a clone is "shallow" (copying references) or
"deep" (copying the target of references) depends on what sort of references
are used (the various sorts of owned references are cloned deeply, most others
are shallow).

The routines will be named C<clone_>I<type>.  In C, they look like this:

    type *clone_type(const type *data, void *allocatorarg,
                     void *(*allocator)(size_t bytes, void *allocatorarg));

The allocator can be specified as NULL to use C<malloc()>.

=item B<--raii=>I<types>

Generate routines that run a callback function, deallocating memory used by
the given types when that function returns, including via exceptional means
(in C, setjmp/longjmp).  In C, there is no 100% reliable way to implement
this; the current implementation works via copying the entire type's dynamic
data into VLAs and then freeing the original type before the callback is run,
which works so long as your compiler's VLAs are exception-safe (most are).

This option implies C<--deallocate=> for the given types.  The routines will
be named C<raii_>I<type>.  In C, they look like this:

    void raii_type(type *data, void *callbackarg,
                   void (*callback)(type *data, void *callbackarg));

=item B<--raii-deinitialize=>I<types>

Like B<--raii>, except with deinitialization rather than deallocation; the
routines will be named C<raii_deinitialize_>I<type>.

=item B<--check=>I<types>

Generate routines that check data to ensure their invariants hold (both those
specified using refinements, and the basic rule that all types must have a
value within range for that type).  If you request this at the same time as
you request the generation of serialization functions, the serialization will
also check the invariants (otherwise, it will only check the invariants to the
extent that the serialization format prevents them being broken).

The routines will be named C<check_>I<type>.  In C, they look like this:

    void check_type(const type *data, void *callbackarg,
                    void (*errorhandler)(const char *problem,
                                         void *callbackarg))

If there are no problems, the error handler won't be called.  Otherwise, it
will be called with a string describing the issue, and the specified
C<callbackarg>.  If the error handler is NULL, then the C<callbackarg> will be
interpreted as an C<int *> and the integer it points to will be set to 1 if an
error occurs, and to 0 if no error occurs.

=item B<--binary=>I<types>

Generate routines that serialize the given types into a binary format, and
deserialize those types from that same format.  The format will be portable
between machines, but not stable with respect to changes in the F<.sd> file,
other than changes to types that are not involved anywhere in the conversion.

The routines will be named C<binary_from_>I<type> and C<binary_to_>I<type>.
In C, they look like this:

    void binary_from_type(const type *data, void *callbackarg,
                          void (*callback)(const char *binary, size_t bytes,
                                           void *callbackarg));
    void binary_to_type(const char *data, size_t bytes, void *callbackarg,
                        void (*callback)(const type *data, void *callbackarg),
                        void (*errorhandler)(const char *problem,
                                             void *callbackarg));

The callback-based calling convention is used in order to avoid the need for a
large family of functions to handle every possible allocation method.  (In
general, callbacks that are given borrowed pointers are one of the most
reliable and adaptable ways to have memory allocation work correctly across
module boundaries.)

=item B<--json=>I<types>

Generate routines that serialize the given type into a JSON-based format, and
-deserialize those types from that same format.  (In C, these routines will use
the F<libjansson> library to do the JSON conversion.)  The format will be
portable between machines, and stable with respect to additions of fields that
have a default value, and changes that merely increase the range of legal
values for a type (although take care, with auto-numbered enums, that new
values are added at the end of the list), but not with respect to other
changes to types involved in the serialization.

The routines will be named C<json_from_>I<type> and C<json_to_>I<type>. In C,
they look like this:

    json_t *json_from_type(const type *data);
    void json_to_type(json_t *json, void *callbackarg, bool ignore_unknown,
                      void (*callback)(const type *data, void *callbackarg),
                      void (*errorhandler)(const char *problem,
                                           void *callbackarg));

Returned C<json_t> values use F<libjansson>'s reference-counting allocation
scheme, and will be returned with a reference count of 1.  C<json_to_type>
will not chnge the reference count of the given C<json_t> pointer.
C<ignore_unknown> controls whether unknown fields are parsed or not.

=item B<--json-raii=>I<types>

This is mostly specific to C, and not particularly useful in other
lanugages. It works like B<--json>, except that C<json_to_>I<type> is named
C<json_raii_to_>I<type> instead, and will deallocate (in the case of
F<libjansson>, decref) the JSON given to it as input, even if the callback
function returns abnormally, or if there is a parse error.

=item B<--config=>I<types>

Generate routines that serialize the given type into a text-based format
intended to be human-editable, and deserialize those types from that same
format.  The format will be portable between machines, and aims to be stable
against as many changes as possible (for instance, enum values will be stored
by name, although numbers will also be acceptable when reading).  The
serialization or deserialization will be done to or from a given filehandle;
for serialization the filehandle should be opened in read-and-write mode so
that comments left by humans editing the file can be retained.

In addition to C<usually> or C<nullable> specifications, you can also give a
default value from which to fill in missing fields on deserialization; on
serialization, defaults will be placed into the file as comments for any
nullable fields that have null values (rather than omitting them altogether,
as is usual for such fields).  This behaviour is optional; the default value
is nullable, using the appropriate undefined reference in the language you are
using.

The routines will be named C<config_from_>I<type> and C<config_to_>I<type>. In
C, they look like this:

    void config_from_type(const type *data, const type *default,
                          FILE *outhandle,
                          void (*errorhandler)(const char *problem,
                                               void *callbackarg));
    void config_to_type(FILE *inhandle, const type *default, void *callbackarg,
                        void (*callback)(const type *data, void *callbackarg),
                        void (*errorhandler)(const char *problem, bool error,
                                             void *callbackarg));

Unlike other routines with an error hander, C<config_to_type> can produce
warnings as well as errors; these will call first the error handler, and then
the callback, with C<error> set to false when calling the handler.  The
handler can be called multiple times, if multiple problems are found.

=back

=head1 F<.sd> FILE FORMAT

The syntax of an F<.sd> file is Perl object notation:

    # this is a comment, from the # to the end of line
    4                       # a number
    'abcde'                 # a literal string
    'this long string is'.
    'broken over lines'     # strings can be broken over lines using '.'
    [1, 2, 3, 4,]           # a list, trailing comma optional
    [qw/foo bar baz/]       # abbreviated syntax for ['foo', 'bar', 'baz']
    {foo => 1, bar => 2,}   # a dictionary, trailing comma optional

(Perl object notation supports more constructs than these, but these are
sufficient to write an F<.sd> file.)  Incidentally, we recommend always
including the trailing comma when splitting a list or dictionary over multiple
lines; some editors get confused otherwise, and it makes it much harder to
introduce bugs due to omitting a comma.

An F<.sd> file consists of a single dictionary.  Each key of the dictionary
defines one type or one constant (with the exception of the special case
C<_include>).

Here's what sort of keys are available:

=head2 Including files

    _include => ['bar.sd', 'baz.sd'],

Just as C header files can include each other, F<structdesc> files can also
include each other.  This is more intelligent than simple copying; instead,
the output files will reference each other.  For instance, if F<foo.sd>
includes F<bar.sd> and F<baz.sd>, then any output generated from F<bar.sd> and
F<baz.sd> will not appear again in the output generated from F<foo.sd>;
instead, it will be referenced in F<foo.sd>'s output (and thus the same sort
of output must be generated from F<bar.sd> and F<baz.sd> for the output from
F<foo.sd> to be usable).

Sometimes (but not always), this referencing requires the filenames of the
referenced files to be known.  In this case, F<structdesc> will guess that
the file is named using the basename specified in the C<_include> directive
and the most common extension for the type of file.  An example of this would
be that the C header file F<foo.h> generated from F<foo.sd> in the example
above will use the C preprocessor's inclusion mechanism to include F<bar.h>
and F<baz.h>.  Normally, the content of the file will not care about the
I<path>; it's up to your build system to take care of that.

Warning: due to limitations in Perl object notation, you can only have one
C<_include> directive in an F<.sd> file, and if you specify more than one, the
earlier ones will be silently ignored.  We recommend placing your C<_include>
directive (if any) at the top of the file to help avoid duplicate directives,
although it can be placed anywhere in the file and still work correctly.

=head2 Defining numeric constants

    foo => 'bar+30',
    bar => 10,

In addition to type definitions and structure layouts, F<.sd> files can define
constants.  These will be available not only within the F<.sd> file, but also
to programs that use F<structdesc>'s output.  The value must be an expression;
this can either be a literal integer or float, or an expression specified as a
string that defines the constant in terms of other constants.  (There is no
requirement for the constants to be listed in any particular order, as the
above example illustrates.)

The name of a constant must be unique within a F<.sd> file and all the files
it includes; it cannot be the same as a struct or union field, or an enum tag
(after C<enumprefix>/C<enumsuffix> have been taken into account).  This is
because some languages use textual substitution to implement constants (and
thus F<structdesc> also implements constants the same way, because there is
no reason not to).

=head2 Numerical types

    digit => [0, 9],
    bignum => ['-inf', '+inf'],
    'float angle' => [0, 'PI*2.0'],

Most types are specified recursively in terms of other types, but eventually,
you reach the bottom-most types that are simply numbers.  These could be the
built-in types F<char> or F<wchar_t> (which are what ASCII and Unicode strings
respectively are made of); or an integer or floating-point type.  These are
written as a two-element list, specifying the minimum and maximum possible
value (C<'+inf'> and C<'-inf'> are the infinity values).  Types specified as
lists are assumed to be integer types; for floating-point types, you use a tag
on the name, as shown above (the example above is defining a type called just
F<angle>, not F<float angle>).

For statically typed languages, F<structdesc> will pick a numerical type with
an appropriate range.  Unlike in C, a numerical type in F<structdesc> does not
carry signedness hints; it could have a range from 0 to 9 yet be signed.  In
general, in languages where it matters, types are always generated signed
unless C<pack> is used to request the tightest possible packing, in which case
all bets are off for the fields for which it is specified; this helps avoid
bugs due to unexpected conversions between signed and unsigned.

TODO: Bignums and floating-point types are not yet supported.  (Especially
because bignums need thought with respect to allocation behaviour in C.)
F<structdesc> currently silently replaces them with the bounds of a 64-bit
integer.

=head2 Structure and union types

    'union foo' => {bar => [0, 4], baz => [0, 8]},
    'struct bar' => {
        _anon_1 => 'foo',
        quux => {type => [-1, 1], usually => 1},
    },

    # The first example here is sugar for:
    'foo' => {
        type => 'union',
        members => {bar => [0, 4], baz => [0, 8]},
    },

Much of the purpose of F<structdesc> is to define structures.  These use a tag
on the name; you write the name as, e.g., C<struct foo> in the dictionary key
to indicate that the dictionary should be interpreted as a structure.  (This
is internally implemented as sugar for refining the built-in C<struct> type
with a C<members> refinment, as shown in the last example above, but the
C<members> refinement should not really be used explicitly.)  However, the
type will be known as just, e.g., C<foo> in the rest of the C<.sd> file, to
save you worrying about the implementation details of other types.  The
dictionary lists the field names, and their types; the order in the C<.sd>
file is arbitrary and in F<structdesc>'s output will be chosen by
F<structdesc> to attempt to produce a structure that can be stored efficiently
in memory.  The type itself can be any numerical type, any built in type,
anything that would be legal as the right hand side of a type definition, or a
string, that names a type that is defined elsewhere.

It is possible for structure fields to have no name, using a name
C<_anon_>I<number> (the numbers must be distinct for different anonymous
fields, due to deficiencies in Perl object notation), but only if they have
structure or union type; in this case, access to the fields of the anonymous
field will be by using their names directly.  (Thus, a C<bar> structure has
fields named C<bar>, C<baz>, and C<quux>.)  This feature is particularly
useful when using built-in structure types like C<counted_list>.

A union is identical to a structure, except that only one of its fields can be
defined at a time, overwriting the memory of the other fields.  This can make
it quite hard to serialize (although unproblematic to I<de>serialize);
F<structdesc> will error out if you attempt to generate code to serialize a
union, except if it's always possible to determine which version of the field
to serialize (either because they all have an explicit C<defined_when>, or
because they're all the same type).  Unions are specified with a C<union> tag
on the name rather than C<struct>, but otherwise work identically.

=head2 Type refinement

    character => {type => 'char'},
    uppercase_letter => {type => 'char', limit_range => [65, 90]},
    character_or_null => {type => 'char', nullable => -300},

Types can be defined as the same as another type, except with certain changes
made (or, as the first example above shows, no changes made, making one type
an alias for another type).  This mechanism is how pretty much all complex
type definitions are created.  (Type refinements can be used directly as
structure fields, or given names, as in the above examples.)  F<structdesc>
will aim to use the same language-level type for the refinement as for the
original type, where possible; often, this isn't possible (the above example
C<character_or_null> clearly can't be stored in a C<char>, because C<-300> is
not a valid vaue for a character in most languages).  Refinements can specify
a great many properties of a type, ranging from refining generic types into
concrete instances of that type, to simply making minor recommendations about
serialization.

The syntax for a type refinement is a dictionary with a C<type> key that
specifies the type to refine, and perhaps other keys that specify refinements
to apply to it.

The possible refinements are listed L<later in this document|/"REFINEMENTS">.

=head1 BUILT-IN TYPES

Here are the types which are defined by F<structdesc> for use in type
definitions.  (They will not be output as definitions in their own right as
part of F<structdesc>'s output; typically, they need heavy refinement to even
make sense as types.)

=head2 Characters and strings

    # Effectively defined like this, but see text
    char     => [1, 127],
    wchar_t  => [1, 1114111],
    
    # This is how strings work in C; but other languages use different
    # definitions
    string => {
        type => 'terminated_list',
        element_type => 'char',
        terminator => 0,

        abstract => 1,       # because we didn't specify allocation rules
    },

The C<char> and C<wchar_t> types represent language-level ASCII and Unicode
characters.  (0 is an illegal value for these, so that it can be used as a
C<terminator> or C<nullable>; sufficiently many languages do this
automatically that to allow the use of 0 as a value would cause problems
trying to port strings between languages.)  They can be assumed to be defined
as shown above, but are not quite identical to the definitions given, because
they have special cases in serialization (a C<counted_list> or
C<terminated_list> of characters will be converted to a string in the
serialization format, rather than the normal representation used for lists).

These are the only built-in types that can be used without refinement.

There is also the C<string> type, which adapts to whatever the most common
format for a string is in the language (many languages have a special-case
type for a string; otherwise, it defaults to a counted list of characters if
the language has a special-case type for a counted list, or otherwise, a
0-terminated list of characters).  Being a L<list type|/"List types">, it
requires a C<reference> or C<maxlen> refinement to describe its memory
management properties.  C<string> can only handle ASCII characters, because
some languages do not have Unicode strings; use C<wstring_t> for an
appropriate format for Unicode strings.

=head2 Enums and bitfields

    # Some examples
    boolean => {type => 'enum', values => [FALSE, TRUE]},
    filemode => {
        type => 'bitfield', 
        enumprefix => 'S_I',
        # leading 0 means octal in Perl object notation
        values => {RUSR => 0400, WUSR => 0200, XUSR => 0100,
                   RGRP => 0040, WGRP => 0020, XGRP => 0010,
                   ROTH => 0004, WOTH => 0002, XOTH => 0001,},
    },
    fruits => {
        type => 'enum',
        enumprefix => 'fruit_',
        values => {apple => 1,
                   banana => 2,
                   cherry => 3,
                   last_fruit => 'fruit_cherry',},
    },
    
    # This sugar is equivalent to the 'boolean' definition above
    'enum boolean' => {values => [FALSE, TRUE]},

Enums and bitfields are very similar; they're types specified by giving an
explicit list of values.  The values have two representations: a name, and a
number.  Typically the name would be used in source code and in human-readable
representations, and the number as the representation of the enum value in
memory and in serialization formats intended for computers.

Thus, to use these types, they must be refined using a C<values> refinement;
this can either specify a list of names that will be auto-numbered, or else
specify a dictionary that gives numbers explicitly.  An auto-numbered enum
uses numbers 0, 1, 2, 3, etc., and an auto-numbered bitfield uses 1, 2, 4, 8,
16, etc..  When auto-numbering, the list order is significant; re-ordering the
list will change which numbers correspond to which elements and thus break
serialization compatibility.  If you give the numbers explicitly, they are not
constrained to such simple patterns; you could use negative or very large
numbers for enums, or repeat numbers (to give aliases for a field), or even
use numbers that aren't a power of 2 for a bitfield (although only if each
individual bit in those numbers has a name, otherwise they wouldn't be legal
values for the bitfield).  You can also use constant expressions for the
numbers, as shown in the C<fruits> example above; enum and bitfield constants
are constants too (although you must use their C<enumprefix>/C<enumsuffix>, if
any, to avoid ambiguity).

The main difference between an enum and a bitfield is that an enum can only
take one of its values at a time (numerically, that is); a bitfield can take
multiple values, via bitwise-ORing them together.  As such, F<structdesc>
considers an enum to have an invariant that the number actually stored must be
one of the enum values, but the invariant on a bitfield is that the data
actually stored contain no bits that don't have names.

The other refinements that are particularly worth noting for enums and
bitfields are the C<enumprefix> and C<enumsuffix> refinements.  These specify
a name transformation that will be used when generating constants for
programmatic use; in the above example, you would write C<S_IRUSR> to get a
C<filemode> value of 256.  The short name C<RUSR> would be used for
serializations that use names rather than numbers for enums, because it would
be clear that the value was a C<filemode> value from context, and so the
namespacing would be less important.

When defining an enum, you can use an C<enum > tag to avoid having to write
the C<< type => 'enum' >> explicity.

=head2 List types

    allocated_pascal_string => {
        type => 'counted_list',
        element_type => 'char',
        list_name => 'string',
        count_name => 'length',
        reference => 'owned',
    },
    c_string_constant => {
        type => 'terminated_list',
        element_type => 'char',
        terminator => 0,
        reference => 'into_array',
    },
    four_character_code => {
        type => 'known_size_list',
        element_type => 'char',
        size => '4',
        maxlen => 4,
    },

There are three built-in list types in F<structdesc>; the difference is to do
with how the length of the list is stored.  A C<counted_list> stores the
length of the list separately; it's internally a structure type (and thus can
be, and often is, used with the C<_anon_>I<number> mechanism in order to embed
its list and count fields directly into another structure).  A
C<terminated_list> has an otherwise illegal value at the end of the list,
meaning that the length can be discovered via scanning the list until the end
is reached.  A C<known_size_list> has a length for which there is some other
method to determine it at runtime, which could be quite complex (e.g. looking
at other structure fields, or even at global variables), although needs to be
simple enough that F<structdesc> can actually work out how long the list is in
order to deallocate or serialize it.

A list must be refined with an C<element_type> in order to specify what is
being stored; a counted list needs C<list_name> and C<count_name> refinements
to name its structure fields; a terminated list needs a C<terminator> that
isn't a legal value for the C<element_type>; and a known-size list needs a
method of calculating its C<size>.

Additionally, one noticeable feature of lists is that they can have varying
lengths; they are thus the first data structure encountered so far that needs
specific memory allocation behaviour.  Lists thus must always be made into
reference types using a C<reference> refinement, or else given a C<maxlen>
refinement (which leaves them as value types that can store the longest
possible list).  The above examples use a range of different memory allocation
schemes; for the known-size list, because the known size is a constant, it
makes sense to use that for C<maxlen> as well, but in general, C<reference> is
the preferred method because hard-coding buffer sizes almost always ends up
leading to bugs or inflexibilities.  See L<the documentation for
C<reference>|/"Reference types"> for more details.

In C, lists are always implemented as contiguous blocks of memory (or pointers
to such blocks when a C<reference> refinement is used).  Most higher-level
languages and serialization formats have a list type that can be used
directly.  When it is, the language's support for storing lengths will be
used, rather than an explicit count or terminator.

=head2 Dictionaries

    digit_names => {
        type => 'numeric_dictionary',
        element_type => {
            type => 'string',
            reference => 'into_array',
        },
        key_type => [0, 9],
    },
    digits_from_names => {
        type => 'known_size_association_list',
        element_type => [0, 9],
        key_type => {
            type => 'string',
            reference => 'into_array',
        },
        reference => 'into_array',
        element_name => 'digit',
        key_name     => 'digit_name',
        size         => 10,
    },

A dictionary is a data structure that associates keys with values.  The most
common way to implement a dictionary is a hash table, an efficient way of
implementing a dictionary of nullable elements via mapping the keys onto a
small space and then using that as an array index; F<structdesc> does not yet
(and may never) support this because there are so many ways in which it can be
implemented.

F<structdesc> does, however, support a built-in type C<numeric_dictionary>
that is a special case of a hash table, where the hash is the identity
function (and thus the table contains one entry for each possible key).  This
has the additional advantages that collisions are impossible, and the values
need not be nullable (thus creating a table that I<always> has a value stored
for each key).

In C, a numeric dictionary is implemented using a fixed-size array, using the
values of the keys directly as array indexes.  This means that negative keys
cannot be used, and the memory usage depends on the largest number used as a
key, rather than the number of keys used.  Both these problems can be worked
around to some extent using the C<relative_to> refinement on the key type.
Don't do this blindly, though; this changes the semantics of your program, and
the refinement is to notify F<structdesc> that you're using an offset on the
keys.  F<structdesc> will not magically change the rest of your program to
work with the offset.

If you want to use dictionaries with keys that aren't small, mostly
consecutive numbers, F<structdesc> does not support hash tables, but it does
support I<association lists> (basically, just a list of key/value pairs with
no duplicated keys).  This is basically just sugar for a list of structures;
the fields of the structure are given by C<key_name> and C<element_name>
refinements.  The association lists types themselves are
C<counted_association_list>, C<terminated_association_list> (which is
terminated using a specific, otherwise illegal, key), and
C<known_size_association_list>; these work the same way as regular lists.

=head1 REFINEMENTS

Most of the power of F<structdesc> comes from the ability to refine types in
various ways.  Here's what you can do with them:

=head2 Invariants

    defined_when  => '.type == TYPE_NUMERICAL',
    nonnull_when  => '.type == TYPE_NUMERICAL',
    bounded_above => '.capacity',
    bounded_below => '.current',
    approximates  => '.revision',
    ranges        => { 1 => [1000,1999], 2 => [2000,2999], 3 => [3000,3999] },
    lags          => 1,

These refinements specify run-time restrictions on the values that data can
have.  C<bounded_above> and C<bounded_below> specify that this value cannot go
higher or lower (respectively) than the given value; C<defined_when> specifies
that this value is meaningless when the given expression is nonzero;
C<nonnull_when> specifies that this value is never null when the given
expression is nonzero (and is meaningful at other times, too; just it can
potentially be null at those times); and C<approximates> specifies that the
value of this value determines the C<ranges> in which another value can lie
(where C<ranges> specifies a dictionary mapping values of this value, to
C<[min, max]> pairs of that value).

The intended semantics are that mutator functions that change I<other> values
also change I<this> value to fix the invariants, if they would be given a
value that breaks the invariant; and mutator functions that change I<this>
value error out if changing it would break the invariants.  (All the legal
invariants are invariants for which mutator functions could implement the
desired behaviour, except C<nonnull_when>, for which this behaviour is
impossible no matter which field the invariant is placed on.)  F<structdesc>
does not yet have support for actually generating such mutator functions.  In
preparation for a time when it does, though, or just to document your code's
behaviour, you can set a C<lags> refinement to specify that a mutator function
should not automatically try to enforce the invariant (which is typically
useful for programs which want the act of enforcing the invariant to have a
side effect).

The argument to C<defined_when>, C<bounded_above>, C<bounded_below>, and
C<approximates> is a I<runtime expression>, which is evaluated by the code
that F<structdesc> generates, not F<structdesc> itself.  The expression is
allowed to do arithmetic, mention constants, access global variables (and
their structure fields, including recursively), and access other fields of the
structure which has the invariant (with syntax like C<2+2>, C<PI>,
C<global.field>, and C<.field> respectively).  The arithmetic syntax is that
of C or Perl, just like for constants.  Reference fields can also be accessed,
but not dereferenced; all accessing them can do is to check for null.
Although the null value of a reference is written as C<0> in a C<nullable>
refinement, the actual null value used is uncertain, although it will evaluate
as false when used like a boolean (and, except in the case of
C<owned_or_value>, where it's hard to get any guarantees on how value types
will act in any given language, non-null values will evaluate as true).  It is
probably unwise to rely on the exact details of the way arithmetic works in
the target language, because F<.sd> files should theoretically be portable to
multiple languages.  Likewise, you need to make your own arrangements to
ensure that global variables actually exist in your target programs.

C<defined_when> deserves some further explanation, because it can have quite a
major effect on cloning and serialization; if a field is not defined as a
result of a C<defined_when> expression evaluating to 0, its value is assumed
to be completely meaningless, unintialized data that should not be read (in
fact, F<structdesc> may well choose not to initialize the field in structures
it produces while it's undefined, and will typically omit it from a
serialization).  In particular, if the field is normally an owned reference,
any value it might have will be assumed to be a sequence of bits that might
randomly happen to look like a pointer, as opposed to an actual pointer that
needs its memory management needs handled.  To help avoid confusion and detect
errors, F<structdesc> will NULL out any references that are undefined in any
data it produces; but it is unwise to rely on this.

F<structdesc> is aware of the debugger program Memcheck (part of Valgrind); if
you include Valgrind's and Memcheck's headers while compiling its output, it
will tell Memcheck that the fields in question are undefined (thus producing
an error from Memcheck if you try to read them).

=head2 Partially defined types

    abstract => 1

A type definition can be specified as only partially defined using the
C<abstract> refinement (which must be given a value of C<1> for "true").  This
has two effects: it tells F<structdesc> not to complain if it is missing
refinements that would be mandatory for its type (this is OK in a partially
defined type so long as the refinements are given when the type is actually
used); and it prevents the partially defined type being mentioned in
F<structdesc>'s output (types defined as refinements of it are defined
directly, rather than in terms of the abstract type).  This is thus mainly
useful for types where some of the details change from use to use, and others
stay the same; the classic example would be defining a string type in C, where
the definition "NUL-terminated list of characters" is always correct, but
cannot be used on its own due to missing memory allocation details.

An C<abstract> refinement cannot be used to postpone giving C<values> for an
enum or bitfield.  (The reason is that enums and bitfield values can be used
in constant expressions, so the F<structdesc> parser needs to be able to find
them early in the compilation process; and it cannot do this if they're
separated from the actual enum or bitfield they apply to.)

=head2 Reference types

    # For example:
    reference => 'array_index', into => 'argv', opaque => 1, mutable => 1,
    reference => 'owned',
    reference => 'owned_realloc', reference_alloclen_name => 'alloclen',
    reference => 'owned_or_static', mutable_reference_name => 'ownedbuf',
    reference => 'backref', levels => 2,

There are two basic methods of storing data in programming languages.  A
I<value type> stores its data directly; copying the value copies the data.
This is the default in F<structdesc>, and is simple to reason about, but does
not work in some situations (e.g. variable-length lists), and can be highly
wasteful of memory in others (such as parse trees).  A I<reference type>
stores its data indirectly, by instead storing some value that allows the
place where the data is stored to be determined; copying the reference does
not copy the data (and both the old and new references can be used to access
it).  In C, references are normally implemented using pointers, although they
can also be implemented as array indexes into a known array.  In order to get
a reference type in F<structdesc>, you refine a value type using the
C<reference> refinement.

One strange property of reference types is that F<structdesc> normally does
not need to know what the type being referenced actually is; it needs to know
its name, but that by itself is sufficient to construct the code in question.
This is handled using an C<opaque> refinement.  Sadly, knowing the name of the
type in the F<.sd> file (but not its definition) is not necessarily enough to
know the language-level name of the type; F<structdesc> will assume that the
type in question is an unrefined structure.  (If F<structdesc> needs to be
able to allocate, clone, serialize, deserialize or verify invariants on the
type, it will need the full definition at some point, although it will be able
to reference code that does the allocation or cloning without having a copy of
that code available.  This means that C<opaque> is still useful in such cases:
it allows the structure to be defined in terms of itself, which would not
normally be possible.)

Reference types have one major issue that does not affect value types: the
lifetime of the data referred to is not obvious from the reference itself.
Because mistakes tracking this are very common, and programs can rapidly
become inconsistent on the issue (thus leading almost inevitably to bugs), and
because F<structdesc> needs to know to be able to copy or deallocate data, a
reference type must specify exactly what its allocation rules are. 

They also have one other common issue: sharing of references (i.e. multiple
references pointing at the same target) can lead to bugs if the data is
mutated without thinking about the consequences.  Sometimes this is desirable,
sometimes it isn't.  As a result, most references will be marked (at the
output language level) as being references via which data cannot be changed,
by default.  If you want to be able to change shared data via a reference,
give C<< mutable => 1 >>.

Here are the possibilities:

=over 4

=item array_index, into_array

The reference refers to some object whose lifetime is not tied to the
reference itself, and which is necessarily going to outlive the reference.
There are two common reasons for this: either the reference points into a
static or global array, or else the reference points into another field of the
same object that contains the reference.  Your program logic might create the
same relationship some other way, although note that in none of these cases
can F<structdesc> confirm that these relationships actually hold!

Anyway, this is one of the simplest cases, because there is no need to do
anything to the referenced data when the reference is deallocated or
deinitialized.  However, cloning (and other operations that move the object in
memory, such as RAIIing) can be more complex; it depends on what the object
the reference points C<into> (a runtime expression).  If the object does not
reference itself, things are easy.  If the object references itself using an
index into an array (C<< reference => 'array_index' >>), things are still
easy; code using the array index will start measuring using the new index
rather than the old index.  If the object references itself using a pointer,
however (C<< reference => 'into_array' >>), the reference will need to be
changed from pointing at the old object, to pointing at the new object.
F<structdesc>'s code can do this, so long as C<into> is set appropriately.  If
it isn't (it can be omitted), the code will work only if the object does not
reference itself.

Of course, the other big difference between C<array_index> and C<into_array>
is the type of the data storage itself.  An C<into_array> reference is an
actual reference, and will be declared as one using the appropriate syntax for
the language in question.  A C<array_index> reference is just an integer, and
will be declared as one (if the array in question or its length is unknown,
the integer will be large enough to hold any index for any theoretical array
that might be used).

Finally, an C<array_index> can always be serialized (F<structdesc> can copy a
number into the serialized output even without knowing what it means); an
C<into_array> cannot be serialized without an C<into> specified (in which
case, it will be serialized via conversion to and from C<array_index>).

=item weak

A rare situation, but another one which is simple for F<structdesc> to handle:
all functions that deallocate or reallocate the referenced object are aware of
this reference, and if the referenced object should be deallocated or
reallocated, this reference will be nulled or mutated to match.  (C<weak> but
not C<nullable> is nearly always a mistake; it could theoretically make sense
on objects that can be reallocated but not deallocated, but F<structdesc>
considers the combination an error.)  Some languages make this easier by
providing language-level support for weak references, but if the visibility
issues can be worked around, a program can do it by hand.  F<structdesc>
cannot check that a reference behaves like this (in particular, its
reallocators and deallocators will not null out or mutate C<weak> references
in other structures), but it knows how to manipulate a reference that does.

Objects containing weak references cannot be cloned, because that would break
the weakness.  They I<can> be serialized, but the reference itself will be
omitted from the serialized form, and become uninitialized upon
deserialization; and the user of F<structdesc>'s code is thus responsible for
reconstructing the reference.

=item backref

Sometimes, an object will have a "backreference", from the object itself to
its owner (or its owner's owner, etc.).  In this case, the object being
referenced is necessarily going to outlive the reference itself.  Both
C<into_array> and C<weak> can correctly be used to describe this situation,
but neither is particularly self-documenting, and neither behaves correctly if
the object's owner is cloned (C<into_array> would leave the backreference
pointing to the original owner, because C<into> cannot be set correctly; with
C<weak>, F<structdesc> couldn't figure out how to clone the object at all).

Thus, a separate reference strategy, C<backref>, is provided to describe the
situation.  When F<structdesc> clones a structure that has backreferences
somewhere inside it, it will adjust the backreferences appropriately.  The
references will also be marked as backreferences in languages (such as Perl)
that use reference counting without cycle detection as a memory allocation
strategy; if they were not marked as such, then the object would require
explicit deallocation, rather than implicit deallocation when the last
reference to it goes stale.

A backreference can have a C<levels> refinement that specifies what the
reference is referencing; 0 indicates a reference from the object to itself, 1
indicates a reference from the object to its owner, and so on.  If it is not
specified, F<structdesc> will try to work it out at runtime, and serialize a
backreference as the value that a hypothetical C<levels> refinement would have
for the object in question.  It is not possible to serialize or deserialize an
object with a backreference by itself; but it is possible to deserialize the
object that the backreference is to, which will serialize or deserialize the
object itself in the process.  (If C<levels> is present, it will be treated
like C<usually> for serialization purposes; because F<structdesc> knows how
many levels back the backreference goes, it will not need to actually place
the field in the serializtion.)

=item owned

The reference is responsible for the object it references; if the reference
changes or gets deinitialized, the object gets deallocated, and if the
reference is cloned, so is the object it references.  This effectively makes
reference types behave like value types.  (This is also the reason why the C
API of the functions that F<structdesc> generates is so complex; there are a
lot of different ways an object can potentially be allocated.  The basic API
used by F<structdesc> is that when it generates an object that owns
references, it owns those references, and will call a callback function and
then deallocate them again (even on abnormal termination); the exception is
cloning, where it will use a provided allocator.)

For this memory allocation scheme, C<< mutable => 1 >> is given by default,
and cannot be disabled even explicitly.  This is safe (because the reference
type acts like a value type), and also necessary (because the ability to
affect the reference target is needed to be able to deallocate it).

=item owned_or_value

Using C<owned> effectively makes reference types act like value types;
therefore, it can be seen as a way to implement variable-sized value types in
languages like C that do not provide first-class support for them.  However,
in some languages, variable-sized value types work just fine, either in
general (e.g. Haskell, from the point of view of the programmer), or in
special cases (e.g. strings in Perl).

Thus, you can specify C<owned_or_value>; the type will be a value type if it
is possible in the language, and an C<owned> reference if it is impossible in
the language.

Here's an example:

    # Type definitions
    string1    => {type => 'terminated_list', element_type => 'char',
                   reference => 'owned', terminator => 0},
    string2    => {type => 'terminated_list', element_type => 'char',
                   reference => 'owned_or_value', terminator => 0},
    string3    => {type => 'terminated_list', element_type => 'char',
                   reference => 'into_array', terminator => 0},
    'struct a' => {s1 => 'string1', s2 => 'string2', s3 => 'string3'},

    # A 'struct a' in C
    struct a foo = {.s1 = strdup("Hello, "),
                    .s2 = strdup("world!"),
                    .s3 = "\n"};

    # An identical 'struct a' in Perl
    our @string_literals = ("\n\0");
    my $foo = {s1 => \ "Hello\0",
               s2 => "world!\0",
               s3 => weaken \ $string_literals[0]};

In C, variable-length strings cannot be a value type, so a reference is used
in both cases.  In Perl, variable-length strings can be; thus,
C<< $foo->{s2} >>, being C<owned_or_value>, is just a plain string.
C<< $foo->{s1} >> is just C<owned>, and thus is a reference to a string,
because F<structdesc> has been told that it should be a reference.  An
C<into_array> is shown as a comparison; this is very easy to represent in C,
which effectively has all its string literals as part of an array in the
data segment, but in Perl, we needed to construct a separate array to point
into.  (It should thus not be surprising that C<into_array> cannot be
deserialized without an C<into>.)

=item owned_realloc

This is a tweak on C<owned> designed for lists.  When an C<owned> list
changes, the code would have to (by the definition of C<owned>) create a new
list, copy all the elements over, and deallocate the old list.  This works,
but is rather wasteful.  An obvious improvement is to mutate the list
in-place, doing the allocate/copy/deallocate (a "reallocation") only if it
gets longer; and a less obvious (but very common) improvement on that is to
allocate some extra space at each cycle so that reallocations are done less
often.

C<< reference => owned_realloc >>, legal only for list types, is used to
support this mechanism.  The only difference to C<owned> from the point of
view of an C<.sd> file is that the object containing the reference needs an
extra field in order to record the amount of space that has been allocated.
Thus, the list must be made into a structure type, using the C<list_name>
refinement, in order to give somewhere to put the field; the field itself is
named with C<reference_alloclen_name>.  F<structdesc> will ensure that the
field is always accurate whenever it does an allocation.  The allocation
length itself can be measured in two ways:

    reference_alloclen_units => 'bytes',     # measure in bytes
    reference_alloclen_units => 'data',      # measure in list elements

F<structdesc> requires this to be specified explicitly, because both
measurement methods are reasonable, and mixing them up is thus a very easy
mistake that can lead to subtle bugs; it's important for making the F<.sd>
file self-documenting, in addition to necessary to generate correct code.

Several languages do this reallocation strategy transparently to the user, in
which case there is no point in doing it by hand.  F<structdesc> will omit the
allocation length field in this case.  For similar reasons, it is omitted from
serializations.

=item owned_or_static, owned_or_static_realloc

Memory management in C is a mess, and these are the result of that mess.  The
problem is that sometimes you have code which, for whatever reason, wants to
pointers to static or RAIIed data (C<into_array>) for some uses of a type, and
yet retain ownership (C<owned>) on other uses.  After trying to refactor some
code that did this, I thought there would be no way to resolve the situation
without a lot of mutability violations.

The problem is that typically, such code tries to track the correct behaviour
of the allocations via location in the program: the part of the code that
creates an object will know whether it's using owned or static allocation for
each field, then it will pass the object to some code that doesn't care what
allocation scheme is used, then it will deallocate the data again when it gets
control (if it was using owned allocation, that is), after first shouting at
the compiler "Hey, I can actually mutate the target of this reference, honest,
I created it! Ignore the fact that it isn't marked as mutable; I had to do
that in case someone else wanted to use the field for a compile-time
constant!".

Clearly, automatically handling such data is difficult (just imagine trying to
make code that does this exception-safe when you only have setjmp and longjmp
to work with).  However, there is a solution, if an awkward one, implemented
by the C<or_static> variants of C<owned> and C<owned_realloc>.  There needs to
be an indication in the object that contains the reference as to whether the
data is owned or not (otherwise, how is F<structdesc> meant to be able to
clone that object?); and owned data needs both a mutable (so it can be
deallocated) and an immutable (so it can be used consistently with static
data) reference to it.  These two requirements neatly coincide; the solution
is to use an immutable reference, and also a nullable mutable reference, which
is always either the same as the immutable reference or nulled out.  (For
C<owned_or_static_realloc>, an alternative solution to the second requirement
is to have a nullable allocation length instead; F<structdesc> implements both
methods, setting the allocation length to 0 for statically allocated data
(which is correct when the reference is null, and correctly illegal when the
reference is non-null), in addition to nulling the mutable reference.)

If you're doing your memory management entirely with F<structdesc> output, you
don't actually need to know the name of the mutable reference; the immutable
reference is the one you should be using (if you care about the mutable one
outside memory management, you're doing things wrong).  However, you can use
the C<mutable_reference_name> refinement to specify a name for it, in case
your code is crazy enough to want to allocate, reallocate, clone, or free
these references manually.

Finally, all this only works on list types that have been made into a structure
type using the C<list_name> refinement, because F<structdesc> needs somewhere
to actually put the mutable reference.  This is rarely a big deal in practice,
because if you're going to all this trouble in the first place, it's probably
because you were using a list type anyway.

=back

=head2 Null and default values

    nullable => 0,
    usually  => 10,

Sometimes, types have an extra value that represents the absence of a value
(for instance, "NUL", ASCII 0, is used by many languages to represent the
absence of a character, and is not considered a legal character by
F<structdesc> for that reason).  The C<nullable> refinement lets you define a
value that represents the absence of a value; this must be outside the normal
range of the type you're refining, or you will get an error.  (This is one of
the few cases in which refining a type I<increases> the number of values it
can hold; as such, F<structdesc> may need to pick a different type in order to
implement the nullability.)  This thus allows F<.sd> files to be
self-documenting with respect to null values.  A type must normally be
numerical to be nullable; a reference type can always be nullable, using
negative numbers for array indexes or zeroes for pointers.

F<structdesc> will often use a separate, space-saving representation for null
values in serialization (especially in formats like JSON, where the
representation used for a null field is simply to omit it from the dictionary
that represents the structure that contains that field).  It is also possible
to get these savings for fields that aren't nullable, too; you can state that
a numerical field C<usually> has a particular value, and then serialization
for that field might use a space-saving representation if it happens to have
that value exactly.  Proper use of C<usually> can thus cut down on the size of
your serialized formats by quite a bit, although changing it will break most
serialization formats (fields that were serialized with the old usual value
may be deserialized with the new usual value).  C<usually> is not respected in
the config serialization format for this reason.

=head2 Numerical type refinements

    pack        => 1,
    relative_to => -3,
    limit_range => [10, 20],      # also works for enums and bitfields

F<structdesc> typically takes care to ensure that its numerical types have
mostly normal behaviour, avoiding unsigned types, ensuring that they are a
whole number of bytes long, that sort of thing.  If you are prepared to handle
the consequences, you can specify C<pack> (with an argument of 1 for "true")
to minimize memory usage rather than maximize clarity and portability; this
will use unsigned types if appropriate, and bitfields if appropriate and
possible (and if it actually saves memory).  The numbers will likewise be
packed in binary serialization format (although not in other serialization
formats; packing in those would be too fragile).

Sometimes numerical types have frustrating or weird ranges; for example,
C<[-2, 250]>, which requires 9 bits when C<pack>ed, and is not legal as a
C<numeric_dictionary> key.  In such a case, it is common for user code to
store values with an offset in order to move them into a neater range; for
instance, storing C<-2> as C<1> and C<250> as C<253> would be reasonable
behaviour for the above range.  Instead of defining the type as C<[1, 253]>,
it is much more self-documenting to define the type as "C<[-2, 250]> relative
to an offset of C<-3>", or in C<.sd> format,

    {type => [-2, 250], relative_to => -3},

F<structdesc> will then understand that if it sees a particular number in the
field, it should decrease it by 3 to get at its true value.  This currently
affects the C<key_type>, C<nullable>, and C<usually> refinements.  It does
I<not> affect runtime expressions in invariants, basically because those have
to work even if they refer to globals that F<structdesc> is unaware of, and
instead of inconsistently applying offsets in runtime expressions, it
consistently ignores them.  The argument to C<relative_to> is a constant
expression.

One other refinement you can place on numerical types is to tighten the range;
C<limit_range> can specify a new range for a type.  (If this is not as least
as tight as the range of the type being refined, this is an error.)  This is
also legal for enums and bitfields, where tightening the range allows you to
effectively produce one enum that is a subset of another.

=head2 Enum and bitfield refinements

    values => [ZERO, ONE, TWO, THREE],
    # equivalent to the above for an enum:
    values => {ONE => 1, THREE => 3, TWO => 2, ZERO => 0},
    # or if it were a bitfield, this would be equivalent instead:
    values => {ONE => 2, THREE => 8, TWO => 4, ZERO => 1},
    
    enumprefix => 'FOO_',
    enumsuffix => '_BAR',

These refinements were explained above in the section about L<enums and
bitfields|/"Enums and bitfields">.  C<values> (which is mandatory) specifies
the values of an enum or bitfield explicitly, using an auto-numbered list or
manually numbered dictionary; and C<enumprefix> and C<enumsuffix> (both of
which are optional) specify a name transformation to use for programmatic use
(but which is not used for serialization).

=head2 List and dictionary refinements

    element_type => [0, 1] # type name, type refinement, or numerical type
    key_type =>     [0, 1] # ditto, for dictionaries only
    list_name => 'entries' # makes the list a structure type
    count_name => 'length' # for counted (association) lists
    terminator => 'MAXE+1' # for terminated (association) lists
    size => '.otherlength' # for known-size (association) lists
    key_name => 'key'      # for association lists
    element_name => 'elem' # for association lists
    maxlen => 5            # for any sort of list
    minlen => 5            # for any sort of list

Lists and dictionaries are defined in terms of an C<element_type>, and for
dictionaries, a C<key_type>; these are anything that could appear on the right
hand side of a type definition (type names, type refinements, or numerical
types specified directly as a range).  Lists can also have a C<list_name>
refinement; if present, the list becomes a structure type, with the list
values themselves stored in a field of the given name.  This is mostly useful
for C<counted_list>, which needs to be a structure type anyway, because it
always has at least two fields (the list itself, and the count, stored in a
field named using the refinement C<count_name>, except in languages that store
list lengths implicitly anyway).  It can also be used to allow for memory
management techniques that require extra fields, such as C<< reference =>
'owned_realloc' >>.

The other sorts of list also need refinements to give their lengths.
Terminated lists have a C<terminator>, a value that's illegal as an element;
this will be stored at the end of the list to allow a loop to know that the
end of the list has been reached (unless there is language-level support for
counted lists, in which case that will be used instead of an explicit
terminator).  This value must be a constant, or constant expression.
Known-size lists have a C<size>, which is a runtime expression; see L<the
description of invariants|/"Invariants"> for more information on the syntax.

Association lists work like regular lists in most respects; being both
dictionary and list types, they require a C<key_type>, but also a length
management refinement (C<count_name>, C<terminator> which applies to the key,
or C<size>).  They also need a C<key_name> and C<element_name> for the
structure that makes up the body of the list.

Finally, invariants can also be given on list lengths.  Having a C<maxlen>
invariant on a list length, specifying a maximum length, allows the list to be
implemented as a fixed-size buffer; this tends to be a bad idea unless the
length in question is very small, but is there to describe the behaviour of
programs that do that.  Of course, you can avoid that problem using
C<reference> and yet still use C<maxlen> to document the behaviour of your
program.  C<minlen> has no particular memory management behaviour, but
specifying a minimum length can also help to reject invalid input.

If you find yourself wanting to use C<maxlen> and C<minlen>, it might be more
appropriate to use a C<numeric_dictionary> rather than a C<list>.

=cut

use lib 'lib', 'desc';
use StructDesc::Parse qw/parse_structdesc/;

use Data::Dumper;

$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Indent = 1;
$Data::Dumper::Deepcopy = 1;

print Dumper(StructDesc::Parse::parse_structdesc_from_path $ARGV[0], []);
